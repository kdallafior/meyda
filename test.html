<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Meyda Test Visualizer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r74/three.js" charset="utf-8"></script>
  <script type="text/javascript" src="meyda.js"></script>
</head>
<body style="margin:0px;">
  <label for="osc1Freq">Frequency:
    <input name="osc1Freq" type="range" min="0" max="1" step="any" id="osc1Freq"></input>
  </label>
  <button type="button" id="switchToMicButton">Switch To Mic</button><br>

  <script>
  //console.log("hello")
(function(){
  'use strict';
  var context = new AudioContext();

  var meyda = null;

  var osc1 = context.createOscillator();
  osc1.type = "sawtooth";
  osc1.start();

  meyda = Meyda.createMeydaAnalyzer({
  	audioContext:context,
  	source:osc1,
  	bufferSize:1024,
    windowingFunction:"blackman"
  });

  document.getElementById("osc1Freq").onchange=function(e){
    osc1.frequency.value = 110+1000*Math.pow(this.value,2);
  };
  document.getElementById("switchToMicButton").onclick = function(){
    navigator.getUserMedia = navigator.webkitGetUserMedia || navigator.getUserMedia;
    var constraints = {video: false, audio: true};
    var successCallback = function(mediaStream) {
      console.log("Success!")
      var source = context.createMediaStreamSource(mediaStream);
      meyda.setSource(source);
      osc1.disconnect();
    };
    var errorCallback = function(err) {
      console.log("Error: ", err  );
      alert("There has been an error accessing the microphone.");
    }
    try{
      navigator.getUserMedia(
        constraints,
        successCallback,
        errorCallback
      );
    }
    catch(e){
      var p = navigator.mediaDevices.getUserMedia(constraints);
      p.then(successCallback);
      p.catch(errorCallback)
    }
  };

  var resolution = 720;
  var aspectRatio = 16/10;
  var scene = new THREE.Scene();
  var camera = new THREE.PerspectiveCamera( 40, aspectRatio, 0.1, 1000 );

  var initializeFFTs = function(number,pointCount){
    var ffts = [];
    for(var i = 0; i < number; i++){
      ffts.push(Array.apply(null, Array(pointCount)).map(Number.prototype.valueOf,0));
    }
    return ffts;
  }

  var material = new THREE.LineBasicMaterial({
    color: 0x00ff00
  });

  var yellowMaterial = new THREE.LineBasicMaterial({
    color: 0x00ffff
  });

  var ffts = initializeFFTs(20, 128);
  var buffer = null;

  var renderer = new THREE.WebGLRenderer();
  renderer.setSize( resolution*aspectRatio, resolution );
  document.body.appendChild( renderer.domElement );

  var light = new THREE.AmbientLight( 0x404040 ); // soft white light
  scene.add( light );

  var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
  directionalLight.position.set( 0, 1, 1 );
  scene.add( directionalLight );

  camera.position.z = 5;

  // Unchanging variables
  var meydaCheck = (meyda !== null); // Moved this out of render loop
  var spectralCentroid = null;
  var length = 1;
  var hex = 0xffff00;
  var dir = new THREE.Vector3( 0, 1, 0 );
  var rightDir = new THREE.Vector3( 1, 0, 0);
  var origin = new THREE.Vector3(1, -6, -15);

  var g = new THREE.Geometry();
  g.vertices.push(new THREE.Vector3(-11,-3,-15));
  g.vertices.push(new THREE.Vector3( 11,-3,-15));

  // Variables we update
  var centroidArrow = new THREE.ArrowHelper( dir, origin, length, hex );
  var rolloffArrow = new THREE.ArrowHelper( dir, origin, length, 0x0000ff );
  var rmsArrow = new THREE.ArrowHelper( rightDir, origin, length, 0xff00ff );
  var lines = new THREE.Group(); // Lets create a seperate group for our lines
  var loudnessLines = new THREE.Group();
  var bufferLine = new THREE.Line(g,material);
  scene.add( centroidArrow );
  scene.add( rolloffArrow );
  scene.add( rmsArrow );
  scene.add( lines );
  scene.add( loudnessLines );
  scene.add( bufferLine );

  var spectralRolloff;
  var spectralCentroid;
  var loudness;
  var rms;

  function render() {
    requestAnimationFrame( render );
    renderer.render( scene, camera );

    for (var c = 0; c < lines.children.length; c++) { // I feel like there is a faster way to do this?
        lines.remove(lines.children[c]); //forEach is slow
    }
    for (var c = 0; c < loudnessLines.children.length; c++) { // I feel like there is a faster way to do this?
        loudnessLines.remove(loudnessLines.children[c]); //forEach is slow
    }

    ffts.pop(); // If we call render in the success call back then we don't need to check every frame
    ffts.unshift(meyda.get('amplitudeSpectrum'));
    buffer = meyda._m.windowedSignal;

    spectralCentroid = meyda.get('spectralCentroid');
    spectralRolloff = meyda.get('spectralRolloff');
    loudness = meyda.get('loudness');
    rms = meyda.get('rms');

    for(var i = 0; i < ffts.length; i++){
      if(ffts[i]){
        var fftslen = ffts[i].length
        let geometry = new THREE.Geometry(); // May be a way to reuse this
        if (fftslen) {
          for(var j = 0; j < fftslen; j++){
            geometry.vertices.push(new THREE.Vector3(-11+(22*j/fftslen),-5+ffts[i][j],-15-i));
          }
        }
        lines.add( new THREE.Line(geometry, material) );
        geometry.dispose();
      }
    }

    if(spectralCentroid && fftslen){ // SpectralCentroid is an awesome variable name
      centroidArrow.position.set(-11+(22*spectralCentroid/fftslen), -6, -15); // We're really just updating the x axis
    }
    if(spectralRolloff && fftslen){ // SpectralCentroid is an awesome variable name
      rolloffArrow.position.set(-11+(spectralRolloff/44100*22), -6, -15); // We're really just updating the x axis
    }
    if(rms && fftslen){ // SpectralCentroid is an awesome variable name
      rmsArrow.position.set(-11, -5+(10*rms), -15); // We're really just updating the x axis
    }
    if(buffer){
      let geometry = new THREE.Geometry();
      for(var i = 0; i < buffer.length; i++) {
        geometry.vertices.push(new THREE.Vector3(-11+22*i/buffer.length,10+buffer[i]*1.5,-35))
      }
      bufferLine.geometry = geometry;
      geometry.dispose();
    }
    if(loudness && loudness.specific){
      for(var i = 0; i < loudness.specific.length; i++){
        let geometry = new THREE.Geometry();
        geometry.vertices.push(new THREE.Vector3(
          -11+22*i/loudness.specific.length,
          -6+loudness.specific[i]*3,
          -15
        ));
        geometry.vertices.push(new THREE.Vector3(
          -11+22*i/loudness.specific.length+22/loudness.specific.length,
          -6+loudness.specific[i]*3,
          -15
        ));
        loudnessLines.add( new THREE.Line(geometry, yellowMaterial) );
        geometry.dispose();
      }
    }
  }
  render();
})();
  </script>
</body>
</html>
